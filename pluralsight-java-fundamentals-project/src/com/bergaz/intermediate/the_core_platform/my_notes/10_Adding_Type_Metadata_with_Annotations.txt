Overview
-The need for type metadata
-Using annotations
-Declaring custom annotations
-Accessing annotations
-Annotation target and retention
-Simplifying element setting
-Annotation element types
-Class-cross reference

The Need to Express Context and Intent
-Programs dont stand alone
    *They fir into a larger picture
    *Incorporates developer's assumption
        -About the type system
        -About the toolset
        -About the execution environment

*Programs incorporate context and intent
context: we expect into run in
intent: out intentions the behavior in that context

-Type system solves much of this issue
-But standard type system isn't enough

Type is able to express intent:
*For example when we implement a run() method we add Runnable implementation to express out intent

Type is unable to express intent:
*For example when we want to override toString method we can use @Override annotation for our intent

The Need to Express Context and Intent
-We need a way to extent the type system
    *We often try to supplement manually
    -Code comments
    -Documentation
    -Just is not enough
    *We need a structured solution
    -Allow tools to act on context and intent

Using Annotations
-Annotations
    *Special types that act as metadata, applied to a specific target
    *Have no direct impact on target, do not change target's behavior

-Annotations must be interpreted
    *Tools
    *Execution environments
    *Any program

-Annotations in code
    *Name always preceded by @ when used
    *Places directly before target
    *Allowable targets vary with annotation

Annotation: @Override
Compiler looks for methods marked with this annotation, verifies there is a method with matching signature that can
be overridden

Annotations And the Core Java Platform:
-Types to create annotations
-Has only a few annotations

Widely used by other tools/environments
-Java EE
-XML processors such as JAXP
-Our customized annotations

Common Java Core Platform Annotations
-Most affect compilation
    *Override
    *Deprecated
    *SuppressWarnings

Declaring Annotations
-We can create custom annotations
    *Acts as custom meta data
    *Provides same capabilities as built-in

Declaring Annotations
-Annotations are special kind of interface
    *Usage is much more restricted, can't be explicitly implemented
    *Implicitly extend Annotation interface
    *Interface behavior not initially apparent

Declaring annotations is similar to interfaces
-Use interface keyword, preceded by an @ symbol
-Declarations allow same modifiers
-Declarations allowed in same places

Annotations can optionally have elements
-Associate values within annotation
-Declared as methods
-Setting is similar to fields

Accessing Annotations
-Annotations available through reflection
    *Call getAnnotation on type/member
-Returns reference to annotation interface
    *Null if does not have annotation of requested type

Annotations can specify availability
-Part of annotation declaration
-Indicated with Retention annotation